#BlueJ class context
comment0.params=version
comment0.target=FullTimingSimulator(int)
comment0.text=\r\n\ Konstruktor,\ der\ die\ zu\ simulierende\ Schaltung\ aufbaut,\ den\ Ruhezustand\r\n\ ermittelt\ und\ die\ Eingabe-Events\ erzeugt.\r\n\ Simuliert\ wird\ je\ nach\ Argument\ eine\ der\ drei\ vorgegebenen\ Schaltungen\r\n\ \ 1\ \=\ Einfacher\ Multiplexer\ 4\ zu\ 1\ \r\n\ \ 2\ \=\ Einfacher\ synchroner,\ r\uFFFDcksetzbarer\ Z\uFFFDhler\ mit\ 4\ Bit\r\n\ \ 3\ \=\ Komplexe\ Schaltung\ mit\ einem\ Z\uFFFDhler\ vielen\ Latches\ und\r\n\ \ \ \ \ \ einigen\ Multiplexern\r\n
comment1.params=inputs\ select\ nselect\ out
comment1.target=void\ buildMux(Signal[],\ Signal[],\ Signal[],\ Signal)
comment1.text=\r\n\ Diese\ Methode\ konstruiert\ einen\ Multiplexer\ aus\ den\ gegebenen\r\n\ Eingangssignalen,\ den\ Steursignalen\ (und\ ihrer\ Negation)\ und\ legt\ den\r\n\ Ausgang\ an\ das\ angegebene\ Signal.\ Die\ gegebene\ Methode\ funktioniert\r\n\ maximal\ bis\ zu\ vier\ Eing\uFFFDngen.\r\n
comment10.params=
comment10.target=void\ setInputEvents2()
comment10.text=\r\n\ Ebenfalls\ die\ Erzeugung\ der\ Stimuli\ f\uFFFDr\ die\ zweite\ eingebaute\ Schaltung\r\n\r\n
comment11.params=
comment11.target=void\ setInputEvents3()
comment11.text=\r\n\ Ebenfalls\ die\ Erzeugung\ der\ Stimuli\ f\uFFFDr\ die\ dritte\ eingebaute\ Schaltung\r\n\r\n
comment12.params=
comment12.target=void\ simulate()
comment12.text=\r\n\ Diese\ Methode\ f\uFFFDhrt\ die\ eigentliche\ Simulation\ durch.\ Dazu\ wird\r\n\ gepr\uFFFDft,\ ob\ in\ der\ EventQueue\ noch\ weitere\ Events\ vorhanden\ sind.\ Ist\r\n\ dies\ der\ Fall,\ dann\ wird\ das\ n\uFFFDchste\ anstehende\ Event\ behandelt.\ Dazu\r\n\ muss\ das\ Event\ die\ Methode\ propagate()\ zur\ Verf\uFFFDgung\ stellen,\ die\r\n\ dann\ das\ betroffene\ Signal\ informiert.\r\n
comment13.params=args
comment13.target=void\ main(java.lang.String[])
comment13.text=\r\n\ Main\ Methode\ dieser\ Klasse.\ Sie\ m\uFFFDssen\ das\ im\ Moment\ noch\ nicht\r\n\ verstehen.\ Diese\ Methode\ wird\ ben\uFFFDtigt,\ wenn\ Sie\ den\ Simulator\ ohne\r\n\ BlueJ\ laufen\ lassen\ wollen.\ Wenn\ Sie\ diese\ Klasse\ in\ BlueJ\ nutzen,\r\n\ dann\ ignorieren\ Sie\ diese\ Methode\ einfach.\r\n\ \r\n\ Wenn\ Sie\ die\ verschiedenen\ Schaltungen\ testen\ wollen,\ dann\ m\uFFFDssen\r\n\ Sie\ den\ Parameter\ des\ Konstruktors\ entsprechend\ \uFFFDndern.\ Das\ k\uFFFDnnen\r\n\ Sie\ nat\uFFFDrlich\ auch\ durch\ Auswertung\ der\ Kommandozeilenparameter\ tuen.\r\n
comment2.params=clk\ reset\ outputs
comment2.target=void\ buildSynCounter(Signal,\ Signal,\ Signal[])
comment2.text=\r\n\ Diese\ Methode\ konstruiert\ einen\ synchronen,\ r\uFFFDcksetzbaren\ Z\uFFFDhler.\r\n\ \uFFFDbergeben\ werden\ ein\ Taktsignal,\ ein\ Reset-Signal\ und\ ein\ Array\ mit\r\n\ Augangssignalen.\ \uFFFDber\ die\ Gr\uFFFD\uFFFDe\ dieses\ Arrays\ wird\ automatisch\ auch\r\n\ die\ Breite\ des\ Z\uFFFDhlers\ bestimmt.\r\n
comment3.params=
comment3.target=void\ buildCircuit1()
comment3.text=\r\n\ Diese\ Methode\ konstruiert\ die\ Schaltung.\ Die\ erzeugten\ Gatter\ und\ die\r\n\ inneren\ Signale\ sind\ nur\ in\ dieser\ Methode\ bekannt,\ da\ sie\ im\ Verlauf\r\n\ der\ Simulation\ implizit\ durch\ die\ Events,\ bzw.\ die\ Signale\ angesprochen\r\n\ werden.Simuliert\ wird\ ein\ einfacher\ Multiplexer\ der\ einen\ aus\ vier\r\n\ Eing\uFFFDngen\ ausw\uFFFDhlt.\r\n
comment4.params=
comment4.target=void\ buildCircuit2()
comment4.text=\r\n\ Diese\ Methode\ konstruiert\ eine\ weitere\ Schaltung.\ \ Simuliert\ wird\r\n\ ein\ einfacher\ vier\ Bit\ synchroner\ Z\uFFFDhler.\r\n
comment5.params=
comment5.target=void\ buildCircuit3()
comment5.text=\r\n\ Diese\ Methode\ konstruiert\ die\ dritte\ m\uFFFDgliche\ Schaltung.\ \ Diese\ ist\r\n\ sehr\ kompliziert\ (enth\uFFFDlt\ ca.\ 150\ Gatter).\ Die\ genaue\ Funktion\r\n\ k\uFFFDnnen\ Sie\ ja\ mal\ versuchen\ herauszubekommen.\r\n
comment6.params=
comment6.target=void\ findSteadyState1()
comment6.text=\r\n\ Diese\ Methode\ ermittelt\ den\ Ruhezustand\ der\ Schaltung.\ Dazu\ werden\r\n\ vern\uFFFDnftige\ Initialwerte\ an\ die\ Eing\uFFFDnge\ angelegt.\ Diese\ Initialwerte\r\n\ m\uFFFDssen\ mindestens\ einmal\ durch\ die\ Schaltung\ propagiert\ werden,\r\n\ bis\ sich\ ein\ stabiler\ Zustand\ einstellt.\ Um\ das\ festzustellen\ gibt\r\n\ es\ verschiedene\ Methoden\ (im\ Gatter\ mitz\uFFFDhlen,\ wie\ oft\ sich\ der\ Wert\r\n\ \uFFFDndert.\ Im\ Signal\ mitz\uFFFDhlen,\ wie\ oft\ es\ ge\uFFFDndert\ wurde).\r\n\ Bei\ diesem\ Propagieren\ darf\ nat\uFFFDrlich\ nicht\ mit\ den\ Zeitverz\uFFFDgerungen\r\n\ gearbeitet\ werden.\ \ Sie\ k\uFFFDnnen\ also\ im\ Grunde\ die\ Wert-Propagierung\r\n\ aus\ der\ ersten\ Teilaufgabe\ benutzen.\r\n
comment7.params=
comment7.target=void\ findSteadyState2()
comment7.text=\r\n\ Genau\ wie\ die\ vorhergehende\ Methode\ nur\ f\uFFFDr\ die\ Schaltung\ zwei\r\n
comment8.params=
comment8.target=void\ findSteadyState3()
comment8.text=\r\n\ Genau\ wie\ die\ vorhergehende\ Methode\ nur\ f\uFFFDr\ die\ Schaltung\ drei\r\n
comment9.params=
comment9.target=void\ setInputEvents1()
comment9.text=\r\n\ Diese\ Methode\ erzeugt\ eine\ Reihe\ von\ Eingabe-Events,\ die\ dann\ zur\r\n\ Stimulation\ der\ Schaltung\ dienen.\ \ Die\ Events\ werden\ durch\ ihren\r\n\ eigenen\ Konstruktor\ in\ die\ EventQueue\ eingetragen,\ so\ dass\ hier\ nur\r\n\ das\ Erzeugen\ der\ Events\ zu\ sehen\ ist.\r\n\ Jedes\ Event\ bekommt\ beim\ Erzeugen\ das\ betroffene\ Signal,\ den\ Zeitpunkt\r\n\ und\ den\ <bold>neuen\ Wert</bold>\ mit.\r\n
numComments=14
